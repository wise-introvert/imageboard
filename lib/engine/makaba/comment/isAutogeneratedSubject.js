import { decodeHTML } from 'entities'

/**
 * This is a reverse-engineered guess of
 * 2ch.hk's subject autogeneration algorithm.
 * For example, it's used in `/b/` and `/rf/`.
 * @param  {string}  subject
 * @param  {string}  content
 * @return {Boolean}
 */
export default function isAutogeneratedSubject(subject, content) {
	// For some weird reason, some characters are not decoded in `subject`:
	// * &amp;
	// * &lt;
	// * &gt;
	const subjectLengthBefore = subject.length
	subject = subject
		.replace(ESCAPED_AMPERSAND_REGEXP, '&')
		.replace(ESCAPED_LESS_THAN_REGEXP, '<')
		.replace(ESCAPED_GREATER_THAN_REGEXP, '>')
	const removedSubjectCharactersCount = subjectLengthBefore - subject.length

	const contentText = decodeHTML(
		content
			.replace(/<br>/g, ' ')
			.replace(/<.+?>/g, '')
	)

	// Trimming at `subject.length` could produce false-positives.
	// So triimming at the max character length instead.
	//
	// // Trimming at the max character length would work for text, but not for UTF-8 characters like emoji.
	// // The reason is that in javascript, `string.length` returns the length of a string in characters,
	// // while `makaba` engine trims by the length of a string in bytes.
	// // Emojis are usually two bytes long.
	// // https://en.wikipedia.org/wiki/UTF-8
	// // So trimming is done at `subject.length` instead.
	// // It's simpler than using npm packages for counting string length in bytes.
	// // const trimAt = MAX_CHARACTER_BYTE_COUNT_LIMIT - removedSubjectCharactersCount
	// const trimAt = subject.length
	// const autogeneratedSubject = contentText.slice(0, trimAt)

	// `removedSubjectCharactersCount` should contain onkly "regular" characters (no emojis, etc).
	// That's because `removedSubjectCharactersCount` is because of removing empty whitespace
	// inside the removed HTML tags.
	const maxCharacterCountLimit = MAX_CHARACTER_BYTE_COUNT_LIMIT - removedSubjectCharactersCount
	const autogeneratedSubject = trimTextAtByteCount(contentText, maxCharacterCountLimit)

	// console.log('^ auto', autogeneratedSubject, '$')
	// console.log('^ subj', subject, '$')

	return subject === autogeneratedSubject
}

const MAX_CHARACTER_BYTE_COUNT_LIMIT = 101

const ESCAPED_AMPERSAND_REGEXP = /&amp;/g
const ESCAPED_LESS_THAN_REGEXP = /&lt;/g
const ESCAPED_GREATER_THAN_REGEXP = /&gt;/g

// https://stackoverflow.com/a/23329386
function getCharByteCountAtIndex(string, i) {
	// `code` is always less than `0xffff` because Javascript uses UTF-16 character encoding.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
	const code = string.charCodeAt(i)
  // "Trail surrogate"
  if (code >= 0xDC00 && code <= 0xDFFF) {
  	return -1
  }
	if (code <= 0x7f) {
		return 1
	}
  if (code > 0x7f && code <= 0x7ff) {
  	return 1
  }
  if (code > 0x7ff && code <= 0xffff) {
  	return 2
  }
}

function trimTextAtByteCount(text, maxByteCount) {
	let byteCountSoFar = 0
	let i = 0
	while (i < text.length) {
		const charByteCount = getCharByteCountAtIndex(text, i)
		byteCountSoFar += charByteCount

		// If the limit was reached, see if the next character is a "trail surrogate".
		// "Trail surrogate" has a "negative" byte count for some reason, maybe only in `makaba` engine.
		if (byteCountSoFar >= maxByteCount) {
			if (i + 1 < text.length) {
				const nextCharByteCount = getCharByteCountAtIndex(text, i + 1)
				if (nextCharByteCount < 0) {
					i++
					byteCountSoFar += nextCharByteCount
				}
			}
		}

		if (byteCountSoFar === maxByteCount) {
			return text.slice(0, i)
		}

		if (byteCountSoFar > maxByteCount) {
			return text.slice(0, i - 1)
		}

		i++
	}

	return text
}