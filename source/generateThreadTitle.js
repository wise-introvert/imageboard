import getPostText from 'social-components/commonjs/utility/post/getPostText'
import generatePostQuote from 'social-components/commonjs/utility/post/generatePostQuote'
import trimText from 'social-components/commonjs/utility/post/trimText'
import censorWords from 'social-components/commonjs/utility/post/censorWords'

/**
 * If `thread.title` is missing then either copy it
 * from the first comment's `title` or attempt to
 * autogenerate it from the first comment's `content`.
 * Also applies censorship rules to `thread.title`
 * if it's either already present or autogenerated.
 * @param {object} thread
 * @param {object[]} [options.censoredWords]
 * @param {object} [options.messages]
 * @param {boolean} [options.parseContent] â€” The `parseContent` option used when constructing an imageboard instance.
 */
export default function generateThreadTitle(thread, options = {}) {
	const {
		// (optional)
		// `censoredWords: object[]?`
		// Compiled word patterns for censoring comment text.
		censoredWords,
		// (optional)
		// `messages: object?`
		// "Messages" ("strings", "labels") used when generating comment `content` text.
		messages,
		// (optional)
		// `parseContent: boolean?`
		// If `parseContent: false` is used to skip parsing comments' `content`
		// when using `Chan` methods then `parseContent: false` option should also be
		// passed here so indicate that the "opening" comment `content`
		// (raw unparsed HTML markup) should be ignored.
		parseContent,
		// (optional)
		// Maximum length of an autogenerated thread title.
		// Is `60` by default.
		maxLength
	} = options
	if (!thread.title) {
		thread.title = getPostTitle(thread.comments[0], {
			messages,
			parseContent,
			maxLength
		})
	}
	if (thread.title && censoredWords) {
		const titleCensored = censorWords(thread.title, censoredWords)
		if (titleCensored !== thread.title) {
			thread.titleCensored = getPostText(titleCensored)
		}
	}
}

function getPostTitle(post, { messages, parseContent, maxLength }) {
	if (post.title) {
		return post.title
	}
	if (parseContent !== false) {
		return generatePostQuote(post, {
			messages,
			maxLength: maxLength || 60,
			stopOnNewLine: true
		})
	}
}