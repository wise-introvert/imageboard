import { canGeneratePostQuoteIgnoringNestedPostQuotes } from 'social-components/commonjs/utility/post/generatePostQuote'

import generatePreview from './generatePreview'
import setInReplyToQuotes, { getGeneratePostQuoteOptions } from './setInReplyToQuotes'
import classifyPostLinks from './classifyPostLinks'
import setPostLinksDefaultText from './setPostLinksDefaultText'

/**
 * Generates autogenerated quotes for a `comment`.
 * Also generates a preview (optional).
 * @param {object} comment
 * @param {number} options.threadId
 * @param {function} options.getCommentById
 * @param {object} [options.messages]
 * @param {number} [options.generatedQuoteMaxLength]
 * @param {number} [options.generatedQuoteFitFactor]
 * @param {number} options.commentLengthLimit
 * @return {boolean} [contentDidChange] Returns `true` if `comment`'s content has changed.
 */
export function generatePostLinksAndUpdatePreview(comment, {
	threadId,
	getCommentById,
	messages,
	generatedQuoteMaxLength,
	generatedQuoteFitFactor,
	commentLengthLimit,
	hasBeenCalledBefore,
	isParentCommentUpdate
}) {
	const content = comment.content
	let contentDidChange
	if (!hasBeenCalledBefore) {
		// `classifyPostLinks()` must precede `setInReplyToQuotes()`,
		// because it sets `postWasDeleted: true` flags for deleted comments.
		classifyPostLinks(content, { getCommentById, threadId })
		if (messages) {
			// `setPostLinksDefaultText()` must come after `classifyPostLinks()`.
			// Set "Deleted comment" `content` for links to deleted comments.
			// Set "Hidden comment" `content` for links to hidden comments.
			// Set "External comment" `content` for links from other threads.
			// Keep "Comment" `content` for links to other comments.
			// (there seem to be no "other" cases)
			if (setPostLinksDefaultText(content, { messages })) {
				contentDidChange = true
			}
		}
	}
	if (!hasBeenCalledBefore || isParentCommentUpdate) {
		// Autogenerate "in reply to" quotes.
		if (setInReplyToQuotes(content, {
			getCommentById,
			messages,
			generatedQuoteMaxLength,
			generatedQuoteFitFactor
		})) {
			contentDidChange = true
		}
	}
	if (!hasBeenCalledBefore || contentDidChange) {
		if (commentLengthLimit) {
			generatePreview(comment, commentLengthLimit)
		}
	}
	return contentDidChange
}

/**
 * Adds `.parseContent()` function to a `comment`.
 * @param {object} comment
 * @param {string} options.boardId
 * @param {number} options.threadId
 * @param {function} options.getCommentById
 * @param {function} options.parseCommentContent — `.parseCommentContent()` method of an imageboard instance.
 * @param {object} [options.messages]
 * @param {number} [options.generatedQuoteMaxLength]
 * @param {number} options.commentLengthLimit
 * @param {boolean} [options.expandReplies] — `expandReplies` option of `imageboard` constructor.
 */
export function addParseContent(comment, {
	boardId,
	threadId,
	getCommentById,
	messages,
	generatedQuoteMaxLength,
	generatedQuoteFitFactor,
	commentLengthLimit,
	expandReplies,
	parseCommentContent
}) {
	let hasBeenCalled
	addOnContentChange(comment, (isParentCommentUpdate) => {
		const hasBeenCalledBefore = hasBeenCalled
		hasBeenCalled = true
		// Set "External comment" for links to other threads.
		// Set "Deleted comment" for links to deleted comments.
		// Set "Hidden comment" for links to hidden comments.
		// Autogenerate "in reply to" quotes for links to all other comments.
		return generatePostLinksAndUpdatePreview(comment, {
			getCommentById,
			threadId,
			messages,
			generatedQuoteMaxLength,
			generatedQuoteFitFactor,
			commentLengthLimit,
			hasBeenCalledBefore,
			isParentCommentUpdate
		})
	}, {
		expandReplies
	})
	// `shouldUpdateReplies` is `undefined` when called from
	// `social-components/source/utility/post/loadResourceLinks.js`,
	// so `shouldUpdateReplies` is assumed to be `true` by default.
	let shouldUpdateRepliesOnNextParse
	comment.parseContent = (options = {}) => {
		if (comment.rawContent) {
			comment.content = comment.rawContent
			delete comment.rawContent
		}
		if (comment.content) {
			function parseContent() {
				parseCommentContent(comment, {
					boardId,
					threadId
				})
			}
			// Parse "in-reply-to" comments so that post quotes
			// are autogenerated correclty,
			// but only if the cited comment doesn't have anything
			// except for `post-link`s.
			let shouldBeReParsedLater
			if (comment.inReplyTo) {
				let _canGeneratePostQuoteIgnoringNestedPostQuotes
				if (options.exhaustive === false) {
					const rawContent = comment.content
					parseContent(comment)
					// Don't autogenerate `post-link` quotes yet,
					// just mark `post-link`s with `_block: true/false`.
					setInReplyToQuotes(
						comment.content,
						{
							getCommentById,
							messages,
							generatedQuoteMaxLength,
							generateQuotes: false
						}
					)
					if (canGeneratePostQuoteIgnoringNestedPostQuotes(comment, getGeneratePostQuoteOptions({
						messages,
						// `generatedQuoteMaxLength` and `generatedQuoteFitFactor`
						// passed here are the "maximum" ones between block `post-link` quotes
						// and inline `post-link` quotes: `inReplyTo` list currently
						// doesn't specify whether this `post` is a reply with a
						// block `post-link` to the quoted comment, or a reply with an
						// inline `post-link` to the quoted comment.
						// `setInReplyToQuotes()` could add that info to `inReplyTo` list
						// (for example, via something like an `_inReplyToQuoteType` list)
						// but implementing that feature doesn't seem like a necessity:
						// instead, the code here doesn't differentiate between an
						// inline `post-link` and a block `post-link`, simply
						// passing the maximum `maxLength` of the two.
						// Since block `post-link` quotes have larger `maxLength`
						// than inline `post-link` quotes (in `setInReplyToQuotes()`)
						// then it's assumed that `generatedQuoteMaxLength` is the
						// maximum of the two, and their `fitFactor`s are the same.
						generatedQuoteMaxLength,
						generatedQuoteFitFactor
					}))) {
						_canGeneratePostQuoteIgnoringNestedPostQuotes = true
						// Don't parse `inReplyTo` comments for this "non-exhaustive" parse.
						// But since the comment isn't fully "parsed" in a sense that
						// its autogenerated post link quotes haven't been set yet,
						// then mark this comments for later re-parsing.
						shouldBeReParsedLater = true
						shouldUpdateRepliesOnNextParse = false
						comment.rawContent = rawContent
					} else {
						// Undo parsing `comment.content`:
						// it will be re-parsed after parsing parent comments' content.
						comment.content = rawContent
					}
				}
				if (!_canGeneratePostQuoteIgnoringNestedPostQuotes) {
					// Parse `inReplyTo` comments.
					// Those comments could be half-parsed for now to reduce
					// the overall parsing time for this comment,
					// hence the `exhaustive: false` flag.
					for (const comment of comment.inReplyTo) {
						if (!comment.contentParsed) {
							comment.parseContent({ exhaustive: false })
						}
					}
					parseContent()
				}
			} else {
				parseContent()
			}
			if (shouldBeReParsedLater) {
				// Passing `generateBlockQuotes: false` could seem like not making any sense,
				// but it is used in `captchan` when parsing comments not starting from the first one:
				// when "Show previous" button is shown and comments are output from after the "latest read" one.
				// In those cases, when the first shown comment quotes an earlier comment
				// having a manually written quote for a post link, such manually written quotes
				// should be moved inside that `post-link`'s `content`.
				// Example: #1235 ">>1234 \n >Quote \n Text" (hidden), #1236 ">>1235 \n Second text" (shown).
				// Without calling `setInReplyToQuotes({ generateBlockQuotes: false })` it would be:
				// #1236 ">>««Quote» \n Text» \n Second text".
				// With calling `setInReplyToQuotes({ generateBlockQuotes: false })` it would be:
				// #1236 ">>«Text» \n Second text".
				// Also, inline `post-link` quotes should be generated too
				// because they're also present in such comment's quotes.
				setInReplyToQuotes(
					comment.content,
					{
						getCommentById,
						messages,
						generatedQuoteMaxLength,
						generateBlockQuotes: false
					}
				)
			} else {
				// This flag is checked in `onContentChange()`.
				comment.contentParsed = true
				// Update autogenerated quotes in child comments.
				comment.onContentChange({
					shouldUpdateReplies: shouldUpdateRepliesOnNextParse
				})
				// `.parseContent()` method is set to a "no op" function
				// instead of `undefined` for convenience.
				// (because it can be called multiple times in `captchan`
				//  being called in `onItemFirstRender()` of `virtual-scroller`)
				comment.parseContent = () => {}
			}
		}
	}
}

/**
 * Adds `onContentChange()` functions to each comment.
 * (`.onContentChange()` is only called from `.parseContent()`).
 * The `onContentChange()` function should be called
 * whenever the comment content is updated (for example,
 * after a link to a YouTube video is parsed and expanded
 * into an embedded attachment). It re-generates comment
 * preview and also if `expandReplies` is `true` it updates
 * the autogenerated quotes in the comment's replies.
 * Returns an array of ids of replies to this comment whose
 * content did change as a result of this comment content's change.
 * For example, when there're replies to this comment having
 * autogenerated quotes those quotes should be re-generated
 * when this comment's content changes.
 * The returned array of reply ids is used in `loadResourceLinks()`
 * function of `social-components`: each of those reply ids
 * will be used to re-render the corresponding posts.
 * @param {object} comment
 * @param {function} updateAutogeneratedContent
 * @param {boolean} [options.expandReplies] — `expandReplies: true` option of `imageboard`.
 * @return {number[]} [description] Returns an array of ids of replies to this comment whose content did change as a result of this comment content's change.
 */
function addOnContentChange(comment, updateAutogeneratedContent, { expandReplies }) {
	// `isParentCommentUpdate` is only passed internally when calling
	// `.onContentChange()` for child comments recursively.
	// `isParentCommentUpdate` should not be passed when calling
	// `.onContentChange()` as a public API.
	// Returns the list of child comment ids whose `content`
	// did change as a result of the parent comment content change.
	comment.onContentChange = (options = {}) => {
		const { isParentCommentUpdate, shouldUpdateReplies } = options
		const autogeneratedContentDidChange = comment.content &&
			updateAutogeneratedContent(isParentCommentUpdate)
		if (isParentCommentUpdate) {
			if (autogeneratedContentDidChange) {
				// Theoretically there can be cases when a post's content
				// is present is quotes on a deeper nesting level.
				// For example, if a parent post is "Video Title" and a
				// child post is just a quote of the parent post
				// ("> Video Title") and a child-of-a-child comment quotes
				// the child comment ("> > Video Title").
				// Such edge cases are dismissed to keep the code simple
				// so a child-of-a-child comment will be something like
				// "> > (link to youtube.com)" in such case.
				return []
			}
		}
		// Don't recurse into updating replies for potentially less CPU usage.
		// Sometimes replies depend on parent's parent reply content.
		// For example, if comment #1 is "Text" and comment #2 is ">>1"
		// and comment #3 is ">>2" then when comment #1 `content` is paresed
		// then only comment #2 `content` is updated to "> Text" and
		// comment #3 `content` is not updated in this case and will
		// just be a "Message" link. The solution is: don't post comments
		// without the actual content.
		// `shouldUpdateReplies` is `undefined` when called from
		// `social-components/source/utility/post/loadResourceLinks.js`,
		// so `shouldUpdateReplies` is assumed to be `true` by default.
		else if (shouldUpdateReplies !== false) {
			if (comment.replies && expandReplies) {
				return comment.replies
					.map(reply => reply.contentParsed && reply.content && reply.onContentChange({ isParentCommentUpdate: true }) ? reply.id : undefined)
					.filter(_ => _)
			}
			return []
		}
	}
}